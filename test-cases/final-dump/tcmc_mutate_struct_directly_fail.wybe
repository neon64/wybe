type combined(T) {
    pub combined(x: T, y: list(T), z: list(T))
}

# we expect that this *should* get optimized into two outByReference ->
# takeReference pairs
pub def appendstuff(l: list(int), l2: list(int), ?result: combined(int)) {
    ?l3 = l ,, l2
    ?result = combined(length(l) + length(l2), [], l2 ,, l)
    # here we have that this mutate isn't specified to be *destructive* yet. RIP
    # !result^y = l3
    foreign lpvm mutate(result, ?result, 8, 1, 16, 0, l3)
    # equivalent to below:
    # ?result = combined(length(l) + length(l2), l ,, l2, l2 ,, l)
}

appendstuff([1,2,3], [4,5,6], ?l2)
!println(combined.x(l2))
!println(combined.y(l2), print)
!println(combined.z(l2), print)